{% load static %}
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Questions</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="{% static 'transcription/questions.css' %}" />
    <link
      rel="stylesheet"
      type="text/css"
      href="{% static 'transcription/result.css' %}" />
  </head>
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-FDVXC6S94X"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-FDVXC6S94X');
</script>
  <body>
    <a href="{% url 'home' %}" class="back-button">Back to Dashboard</a>

    <div class="container">
      <h1>Questions for {{ assignment.title }}</h1>
      <div id="progress-indicator">
        Progress: <span id="completed-questions">0</span>/<span
          id="total-questions"
          >{{ questions|length }}</span
        >
        (<span id="completion-percentage">0</span>%)
      </div>
      <div class="content-wrapper">
        <div class="flashcard-container">
          {% for question in questions %}
          <div
            class="flashcard"
            data-question-id="{{ question.id }}"
            data-attempts-left="{{ question.attempts_left }}">
            <div
              class="question-text"
              onclick="speakQuestion('{{ question.question_text }}')">
              <h4>{{ question.question_text }}</h4>
            </div>
            <div class="attempts-left">
              <span>{{ question.attempts_left }}</span>
            </div>
            <div class="mic" data-question-id="{{ question.id }}">
              <div class="mic-icon"></div>
              <div class="loading-animation"></div>
            </div>
          </div>
          {% endfor %}
        </div>
        <div class="instructions">
          <h2>Instructions</h2>
          <ol>
            <li>Click on the question text to hear it spoken aloud.</li>
            <li>Click the microphone icon to start recording your answer.</li>
            <li>Speak clearly and concisely.</li>
            <li>Recording will automatically stop after 8 seconds.</li>
            <li>
              Your answer will be evaluated, and feedback will be provided.
            </li>
            <li>
              You have limited attempts for each question, use them wisely!
            </li>
          </ol>
        </div>
      </div>
    </div>

    <form id="audioForm" method="post" action="{% url 'save_audio' %}">
      {% csrf_token %}
      <input type="hidden" name="audio_data" id="audio_data" />
      <input type="hidden" name="assignment_id" value="{{ assignment.id }}" />
      <input type="hidden" name="question_id" id="question_id" />
    </form>

    <div id="result-tab" class="result-tab hidden">
      <div class="close-btn" onclick="closeResultTab()">Ã—</div>
      <h2>Original Question:</h2>
      <p id="question-text"></p>
      <h2>Your Answer:</h2>
      <p id="transcribed-text"></p>
      <h2>Score:</h2>
      <p id="score"></p>
      <h2>Feedback:</h2>
      <p id="feedback"></p>
    </div>

    <script>
        document.addEventListener("DOMContentLoaded", () => {
            const flashcards = document.querySelectorAll(".flashcard");

            flashcards.forEach((card) => {
              const questionId = card.getAttribute("data-question-id");
              const attemptsLeft = parseInt(card.getAttribute("data-attempts-left"));

              updateCardState(card, attemptsLeft);
            });

            updateProgress();
          });

          let isRecording = false;
          let mediaRecorder;
          let audioChunks = [];
          let isSubmitting = false;

      const speakQuestion = (questionText) => {
        if ("speechSynthesis" in window) {
          const speech = new SpeechSynthesisUtterance(questionText);
          speech.lang = "fr-FR";
          speech.rate = 0.9;
          speech.pitch = 1.2;

          const voices = window.speechSynthesis.getVoices();
          const frenchVoice = voices.find((voice) =>
            voice.name.toLowerCase().includes("french")
          );
          if (frenchVoice) {
            speech.voice = frenchVoice;
          }

          window.speechSynthesis.speak(speech);
        } else {
          console.error("Text-to-speech is not supported.");
        }
      };

      const toggleRecording = async (questionId, micDiv) => {
        if (isSubmitting) return;

        const flashcard = micDiv.closest(".flashcard");
        const attemptsLeft = parseInt(flashcard.getAttribute("data-attempts-left"));

        if (attemptsLeft > 0) {
          if (!isRecording) {
            await startRecording(questionId, micDiv);
          } else {
            stopRecording(questionId, micDiv);
          }
        }
      };

      let recordingTimer;

      const startRecording = async (questionId, micDiv) => {
        if (navigator.mediaDevices) {
          try {
            const stream = await navigator.mediaDevices.getUserMedia({
              audio: true,
            });
            mediaRecorder = new MediaRecorder(stream);

            audioChunks = [];

            mediaRecorder.ondataavailable = (event) => {
              audioChunks.push(event.data);
            };

            mediaRecorder.onstop = () => {
              const audioBlob = new Blob(audioChunks, { type: "audio/wav" });
              const reader = new FileReader();
              reader.readAsArrayBuffer(audioBlob);
              reader.onloadend = () => {
                const base64String = btoa(
                  new Uint8Array(reader.result).reduce(
                    (data, byte) => data + String.fromCharCode(byte),
                    ""
                  )
                );
                document.getElementById("audio_data").value = base64String;
                document.getElementById("question_id").value = questionId;
                submitAudioForm(questionId, micDiv);
              };
            };

            mediaRecorder.start();
            isRecording = true;
            micDiv.classList.add("recording");
            micDiv.querySelector(".loading-animation").style.display = "none"; // Hide loading animation during recording

            recordingTimer = setTimeout(() => {
              stopRecording(questionId, micDiv);
            }, 8000);

          } catch (error) {
            console.error("Error accessing audio", error);
          }
        } else {
          console.error(
            "MediaRecorder or getUserMedia is not supported by this browser."
          );
        }
      };

      const stopRecording = (questionId, micDiv) => {
        if (isRecording && mediaRecorder) {
          clearTimeout(recordingTimer);
          mediaRecorder.stop();
          isRecording = false;
          micDiv.classList.remove("recording");
          micDiv.querySelector(".loading-animation").style.display = "block"; // Show loading animation after recording stops
        }
      };

      const submitAudioForm = (questionId, micDiv) => {
        isSubmitting = true;
        micDiv.querySelector(".loading-animation").style.opacity = "1";
        disableAllMicButtons();

        const formData = new FormData(document.getElementById("audioForm"));
        fetch("{% url 'save_audio' %}", {
          method: "POST",
          body: formData,
        })
          .then((response) => response.json())
          .then((data) => {
            showResultTab(data);
            updateAttemptsLeft(questionId, micDiv);
          })
          .catch((error) => console.error("Error:", error))
          .finally(() => {
            isSubmitting = false;
            micDiv.querySelector(".loading-animation").style.opacity = "0";
            micDiv.querySelector(".loading-animation").style.display = "none";
            enableAllMicButtons();
          });
      };

      const disableAllMicButtons = () => {
        document.querySelectorAll(".mic").forEach(mic => {
          mic.style.pointerEvents = "none";
          mic.style.opacity = "0.5";
        });
      };

      const enableAllMicButtons = () => {
        document.querySelectorAll(".mic").forEach(mic => {
          const flashcard = mic.closest(".flashcard");
          const attemptsLeft = parseInt(flashcard.getAttribute("data-attempts-left"));
          if (attemptsLeft > 0) {
            mic.style.pointerEvents = "auto";
            mic.style.opacity = "1";
          }
        });
      };

      const showResultTab = (data) => {
        document.getElementById("question-text").textContent = data.question;
        document.getElementById("transcribed-text").textContent = data.transcribed_text;
        document.getElementById("score").textContent = `${data.score}`;
        document.getElementById("feedback").textContent = data.feedback;

        const resultTab = document.getElementById("result-tab");
        resultTab.classList.remove("hidden");
      };

      const closeResultTab = () => {
        const resultTab = document.getElementById("result-tab");
        resultTab.classList.add("hidden");
      };

      const updateAttemptsLeft = (questionId, micDiv) => {
        const flashcard = micDiv.closest(".flashcard");
        let attemptsLeft = parseInt(flashcard.getAttribute("data-attempts-left")) - 1;
        attemptsLeft = Math.max(attemptsLeft, 0);

        flashcard.setAttribute("data-attempts-left", attemptsLeft);
        flashcard.querySelector(".attempts-left span").textContent = attemptsLeft;

        updateCardState(flashcard, attemptsLeft);

        const formData = new FormData();
        formData.append("question_id", questionId);
        formData.append("attempts_left", attemptsLeft);
        formData.append("csrfmiddlewaretoken", "{{ csrf_token }}");

        fetch("{% url 'update_question_status' %}", {
          method: "POST",
          body: formData,
        })
          .then((response) => response.json())
          .then((data) => {
            if (data.status === "success") {
              updateProgress();
            }
          })
          .catch((error) =>
            console.error("Error updating question status:", error)
          );
      };

      const updateCardState = (card, attemptsLeft) => {
        const micDiv = card.querySelector(".mic");
        micDiv.removeEventListener("click", micClickHandler);

        if (attemptsLeft === 0) {
          card.classList.add("locked");
          stopRecording(card.getAttribute("data-question-id"), micDiv);
        } else {
          card.classList.remove("locked");
          micDiv.addEventListener("click", micClickHandler);
        }
      };

      const micClickHandler = function() {
        const card = this.closest(".flashcard");
        const questionId = card.getAttribute("data-question-id");
        toggleRecording(questionId, this);
      };

      function updateProgress() {
        const completedQuestions = document.querySelectorAll('.flashcard[data-attempts-left="0"]').length;
        const totalQuestions = {{ questions|length }};
        const percentage = Math.round((completedQuestions / totalQuestions) * 100);

        document.getElementById('completed-questions').textContent = completedQuestions;
        document.getElementById('completion-percentage').textContent = percentage;

        fetch("{% url 'update_question_progress' %}", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-CSRFToken": "{{ csrf_token }}"
          },
          body: JSON.stringify({
            assignment_id: "{{ assignment.id }}",
            completed_questions: completedQuestions,
            total_questions: totalQuestions
          })
        })
        .then(response => response.json())
        .then(data => console.log('Progress updated:', data))
        .catch(error => console.error('Error updating progress:', error));
      }
    </script>
  </body>
</html>
