{% load static %}
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Questions</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="{% static 'transcription/questions.css' %}" />
    <link
      rel="stylesheet"
      type="text/css"
      href="{% static 'transcription/result.css' %}" />
  </head>
  <body>
    <h1>Questions for {{ assignment.title }}</h1>
    <div class="flashcard-container">
      {% for question in questions %}
      <div
        class="flashcard"
        data-question-id="{{ question.id }}"
        data-has-done="{{ question.has_done }}">
        <h4>{{ question.question_text }}</h4>
        <div
          class="text-to-speech"
          onclick="speakAndRecord('{{ question.question_text }}', '{{ question.id }}')">
          ðŸ‘¾
        </div>
        <div class="mic" data-question-id="{{ question.id }}">
          <i class="mic-icon"></i>
          <div class="mic-shadow"></div>
        </div>
      </div>
      {% endfor %}
    </div>

    <form id="audioForm" method="post" action="{% url 'save_audio' %}">
      {% csrf_token %}
      <input type="hidden" name="audio_data" id="audio_data" />
      <input type="hidden" name="assignment_id" value="{{ assignment.id }}" />
      <input type="hidden" name="question_id" id="question_id" />
      <input type="hidden" name="question_has_done" id="question_has_done" />
    </form>

    <div id="result-tab" class="result-tab hidden">
      <div class="close-btn" onclick="closeResultTab()">Ã—</div>
      <h2>Original Question:</h2>
      <p id="question-text"></p>

      <h2>Your Answer:</h2>
      <p id="transcribed-text"></p>

      <h2>Expected Answer:</h2>
      <p id="expected-answer"></p>

      <h2>Your Score:</h2>
      <p id="score"></p>
    </div>

    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const flashcards = document.querySelectorAll(".flashcard");

        flashcards.forEach((card) => {
          const questionId = card.getAttribute("data-question-id");
          const hasDone = card.getAttribute("data-has-done") === "True";

          if (hasDone) {
            card.classList.add("locked");
          } else {
            const micDiv = card.querySelector(".mic");
            micDiv.addEventListener("click", () => {
              toggleRecording(questionId, micDiv);
            });
          }
        });
      });

      let isRecording = false;
      let mediaRecorder;
      let audioChunks = [];

      const speakAndRecord = (questionText, questionId) => {
        speakQuestion(questionText);
        setTimeout(() => {
          const micDiv = document.querySelector(
            `[data-question-id='${questionId}'] .mic`
          );
          toggleRecording(questionId, micDiv);
        }, 3000);
      };

      const toggleRecording = async (questionId, micDiv) => {
        if (!isRecording) {
          await startRecording(questionId, micDiv);
        } else {
          stopRecording(questionId, micDiv);
        }
      };

      const startRecording = async (questionId, micDiv) => {
        if (navigator.mediaDevices) {
          try {
            const stream = await navigator.mediaDevices.getUserMedia({
              audio: true,
            });
            mediaRecorder = new MediaRecorder(stream);

            mediaRecorder.ondataavailable = (event) => {
              audioChunks.push(event.data);
            };

            mediaRecorder.onstop = () => {
              const audioBlob = new Blob(audioChunks, { type: "audio/wav" });
              const reader = new FileReader();
              reader.readAsArrayBuffer(audioBlob);
              reader.onloadend = () => {
                const base64String = btoa(
                  new Uint8Array(reader.result).reduce(
                    (data, byte) => data + String.fromCharCode(byte),
                    ""
                  )
                );
                document.getElementById("audio_data").value = base64String;
                document.getElementById("question_id").value = questionId;
                submitAudioForm(questionId, micDiv);
              };
            };

            mediaRecorder.start();
            isRecording = true;
            micDiv.classList.add("recording");
          } catch (error) {
            console.error("Error accessing audio", error);
          }
        } else {
          console.error(
            "MediaRecorder or getUserMedia is not supported by this browser."
          );
        }
      };

      const stopRecording = (questionId, micDiv) => {
        if (isRecording && mediaRecorder) {
          mediaRecorder.stop();
          isRecording = false;
          micDiv.classList.remove("recording");
        }
      };

      const submitAudioForm = (questionId, micDiv) => {
        const formData = new FormData(document.getElementById("audioForm"));
        fetch("{% url 'save_audio' %}", {
          method: "POST",
          body: formData,
        })
          .then((response) => response.json())
          .then((data) => {
            showResultTab(data);
            lockAnsweredQuestion(questionId, micDiv);
          })
          .catch((error) => console.error("Error:", error));
      };

      const showResultTab = (data) => {
        document.getElementById("question-text").textContent = data.question;
        document.getElementById("transcribed-text").textContent =
          data.transcribed_text;
        document.getElementById("expected-answer").textContent = data.answer;
        document.getElementById("score").textContent = `${data.score}%`;

        const resultTab = document.getElementById("result-tab");
        resultTab.classList.remove("hidden");
      };

      const closeResultTab = () => {
        const resultTab = document.getElementById("result-tab");
        resultTab.classList.add("hidden");
      };

      const lockAnsweredQuestion = (questionId, micDiv) => {
        const formData = new FormData();
        formData.append("question_id", questionId);
        formData.append("question_has_done", "true");
        formData.append("csrfmiddlewaretoken", "{{ csrf_token }}");

        fetch("{% url 'update_question_status' %}", {
          method: "POST",
          body: formData,
        })
          .then((response) => response.json())
          .then((data) => {
            if (data.status === "success") {
              const flashcard = micDiv.closest(".flashcard");
              flashcard.classList.add("locked");
            }
          })
          .catch((error) =>
            console.error("Error updating question status:", error)
          );
      };

      const speakQuestion = (questionText) => {
        if ("speechSynthesis" in window) {
          const speech = new SpeechSynthesisUtterance(questionText);
          speech.lang = "fr-FR";
          speech.rate = 0.9;
          speech.pitch = 1.2;

          const voices = window.speechSynthesis.getVoices();
          const frenchVoice = voices.find((voice) =>
            voice.name.toLowerCase().includes("french")
          );
          if (frenchVoice) {
            speech.voice = frenchVoice;
          }

          window.speechSynthesis.speak(speech);
        } else {
          console.error("Text-to-speech is not supported.");
        }
      };

      const updateQuestionStatus = (questionId, hasDone) => {
        fetch("{% url 'update_question_status' %}", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            question_id: questionId,
            has_done: hasDone,
            csrfmiddlewaretoken: "{{ csrf_token }}",
          }),
        });
      };
    </script>
  </body>
</html>
