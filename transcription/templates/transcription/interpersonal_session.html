{% load static %}

{% block content %}
<style>
    @import url("https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap");

    body, html {
        margin: 0;
        padding: 0;
        font-family: "Poppins", sans-serif;
        height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        background: linear-gradient(45deg, #3cdfff, #89C5FD);
        background-size: 400% 400%;
        animation: gradientBG 15s ease infinite;
    }

    @keyframes gradientBG {
        0% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
        100% { background-position: 0% 50%; }
    }

    .container {
        width: 70vh; /* Slightly reduced width */
        max-width: 700px; /* Adjusted max-width */
        height: 45vh; /* Slightly reduced height */
        padding: 2rem;
        background-color: rgba(255, 255, 255, 0.9);
        border-radius: 20px;
        box-shadow: 0 8px 32px rgba(31, 38, 135, 0.2);
        backdrop-filter: blur(10px);
        display: flex;
        flex-direction: column;
        justify-content: space-between; /* Changed to space-between for better distribution */
        align-items: center;
        transition: height 0.3s ease;
    }

    .container.summary-active {
        height: 80vh;
        overflow-y: auto;
    }

    h1 {
        color: #0288D1;
        margin-bottom: 0.5rem;
        font-size: 2.5rem; /* Slightly reduced font size */
    }

    p {
        color: #01579B;
        margin-bottom: 0.5rem;
        font-size: 1.2rem; /* Slightly reduced font size */
    }

    #questionContainer {
        padding: 15px;
        transition: background-color 0.5s ease;
        border-radius: 10px;
        width: 100%;
        flex-grow: 1;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
    }

    #questionText {
        font-size: 1.8rem;
        margin-bottom: 1rem;
        text-align: center;
    }

    button {
        background-color: #4CAF50;
        width: 12rem; /* Increased width */
        height: 5rem; /* Increased height */
        border: none;
        color: white;
        padding: 15px 32px;
        text-align: center;
        text-decoration: none;
        display: inline-block;
        font-size: 1.2rem; /* Increased font size */
        margin: 1rem 0;
        cursor: pointer;
        border-radius: 12px;
        transition: all 0.3s ease;
    }

    button:hover {
        background-color: #45a049;
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
    }

    #summary {
        margin-top: 2rem;
        width: 100%;
    }

    #summaryContent {
        text-align: left;
    }

    #summaryContent h3 {
        color: #0288D1;
        margin-top: 1.5rem;
    }

    #summaryContent p {
        text-align: left;
        margin-bottom: 0.5rem;
    }

    .mic {
        cursor: pointer;
        width: 120px; /* Increased size */
        height: 120px; /* Increased size */
        border-radius: 50%;
        background: #03A9F4;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.3s ease;
        margin: 1rem auto;
    }

    .mic:hover {
        background: #039BE5;
        transform: scale(1.05);
    }

    .mic-icon {
        width: 60px; /* Increased size */
        height: 60px; /* Increased size */
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='white'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z'%3E%3C/path%3E%3C/svg%3E");
        background-size: contain;
        background-repeat: no-repeat;
    }


    .mic.recording {
        animation: pulse 1.5s infinite;
        background: #F44336;
    }

    .mic.processing {
        animation: wave 2s ease-in-out infinite;
        background: #FFA000;
    }

    @keyframes pulse {
        0% { transform: scale(1); }
        50% { transform: scale(1.1); }
        100% { transform: scale(1); }
    }

    @keyframes wave {
        0% { transform: scale(1) rotate(0deg); }
        25% { transform: scale(1.1) rotate(90deg); }
        50% { transform: scale(1) rotate(180deg); }
        75% { transform: scale(1.1) rotate(270deg); }
        100% { transform: scale(1) rotate(360deg); }
    }

    .site-wide-loading {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 9999;
    }

    .loading-spinner {
        width: 50px;
        height: 50px;
        border: 5px solid #f3f3f3;
        border-top: 5px solid #3498db;
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
</style>

<div class="container" id="mainContainer">
    <h1>{{ session.title }}</h1>
    <p>Number of questions: {{ session.questions.count }}</p>
    
    {% if not is_completed %}
    <div id="questionContainer">
        <h2 id="questionText"></h2>
        <input type="hidden" id="audioData" class="audio-data" value="">
        <button id="startSession">Start Session</button>
        <div id="micContainer" style="display: none;">
            <div class="mic">
                <div class="mic-icon"></div>
            </div>
        </div>
    </div>

    <form id="audioForm" method="post" action="{% url 'save_interpersonal_audio' %}">
        {% csrf_token %}
        <input type="hidden" name="audio_data" id="audio_data" />
        <input type="hidden" name="question_id" id="question_id" />
        <input type="hidden" name="session_id" id="session_id" value="{{ session.id }}" />
    </form>

    <div id="summary" style="display: none;">
        <h2>Session Summary</h2>
        <div id="summaryContent"></div>
    </div>
    {% else %}
    <h2>Session completed!</h2>
    {% endif %}
</div>

<div id="siteWideLoading" class="site-wide-loading" style="display: none;">
    <div class="loading-spinner"></div>
</div>

{{ questions_data|safe }}
{{ transcriptions|safe }}
<script>
    document.addEventListener('DOMContentLoaded', function() {
        
        const questions = JSON.parse('{{ questions_data|escapejs }}');
        const transcriptions = JSON.parse('{{ transcriptions|escapejs }}');
            
        console.log('Loaded questions:', questions);
        console.log('Loaded transcriptions:', transcriptions);
        let currentQuestionIndex = 0;
        const questionContainer = document.getElementById('questionContainer');
        const questionText = document.getElementById('questionText');
        const audioDataInput = document.getElementById('audioData');
        const startButton = document.getElementById('startSession');
        const micContainer = document.getElementById('micContainer');
        const mic = document.querySelector('.mic');
        const summary = document.getElementById('summary');
        const summaryContent = document.getElementById('summaryContent');
        
        let mediaRecorder;
        let audioChunks = [];
        let isRecording = false;
        let isCompleted = {{ is_completed|yesno:"true,false" }};
        let recordingTimeout;
        let audioBlob;
        let allResponses = [];
        const totalQuestions = questions.length;
        
        function playAudio(audioUrl) {
            return new Promise((resolve, reject) => {
                const audio = new Audio();
                audio.onerror = (e) => {
                    console.error('Error playing audio:', e);
                    console.error('Audio source:', audioUrl);
                    alert(`Error playing audio. Source: ${audioUrl}. Please check the console for details.`);
                    reject(e);
                };
                audio.onloadedmetadata = () => {
                    console.log('Audio metadata loaded successfully');
                };
                audio.oncanplaythrough = () => {
                    console.log('Audio can play through');
                    audio.play().then(() => {
                        console.log('Audio started playing');
                        audio.onended = () => {
                            console.log('Audio finished playing');
                            resolve();
                        };
                    }).catch(e => {
                        console.error('Error playing audio:', e);
                        reject(e);
                    });
                };
                audio.src = audioUrl;
            });
        }

    async function startRecording() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            mediaRecorder = new MediaRecorder(stream);
            audioChunks = [];
    
            mediaRecorder.ondataavailable = (event) => {
                audioChunks.push(event.data);
            };
    
            mediaRecorder.onstop = () => {
                audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                processAudioBlob();
            };
    
            mediaRecorder.start();
            isRecording = true;
            mic.classList.add('recording');
    
            recordingTimeout = setTimeout(() => {
                stopRecording();
            }, 8000);
        } catch (error) {
            console.error('Error starting recording:', error);
            alert('Failed to start recording. Please check your microphone permissions.');
            moveToNextQuestion();
        }
    }
    
    function stopRecording() {
        if (isRecording && mediaRecorder) {
            clearTimeout(recordingTimeout);
            mediaRecorder.stop();
            isRecording = false;
            mic.classList.remove('recording');
        }
    }
    
    function processAudioBlob() {
        const reader = new FileReader();
        reader.readAsDataURL(audioBlob);
        reader.onloadend = function() {
            const base64AudioData = reader.result.split(',')[1];
            submitAudioResponse(base64AudioData);
        };
    }

    function submitAudioResponse(base64AudioData) {
        console.log("Submitting audio response");
        document.getElementById("audio_data").value = base64AudioData;
        document.getElementById("question_id").value = questions[currentQuestionIndex].id;
    
        const formData = new FormData(document.getElementById("audioForm"));
    
        mic.classList.remove('recording');
        mic.classList.add('processing');
    
        fetch("{% url 'save_interpersonal_audio' %}", {
            method: 'POST',
            body: formData
        })
        .then(response => {
            if (!response.ok) {
                return response.json().then(err => {
                    throw new Error(`HTTP error! status: ${response.status}, message: ${err.error || 'Unknown error'}`);
                });
            }
            return response.json();
        })
        .then(data => {
            mic.classList.remove('processing');
            updateSummary(data);
            moveToNextQuestion();
        })
        .catch(error => {
            console.error('Error submitting audio:', error);
            mic.classList.remove('processing');
            alert('An error occurred while submitting the audio. Moving to the next question.');
            moveToNextQuestion();
        });
    }

    function updateSummary(data) {
        const currentTranscription = transcriptions[currentQuestionIndex];
        
        allResponses.push({
            question: data.question,
            answer: data.transcribed_text,
            score: data.score,
            feedback: data.feedback
        });
    
        console.log('Stored responses:', allResponses);
    
        if (allResponses.length === totalQuestions) {
            displayFinalSummary();
        }
    }

    function displayFinalSummary() {
        document.getElementById('siteWideLoading').style.display = 'flex';
        
        setTimeout(() => {
            summaryContent.innerHTML = '';
        
            allResponses.forEach((response, index) => {
                const questionSummary = document.createElement('div');
                questionSummary.innerHTML = `
                    <h3>Question ${index + 1}</h3>
                    <p><strong>Original Question:</strong> ${response.question}</p>
                    <p><strong>Your Answer:</strong> ${response.answer}</p>
                    <p><strong>AI Score:</strong> ${response.score}%</p>
                    <p><strong>AI Feedback:</strong> ${response.feedback}</p>
                `;
                summaryContent.appendChild(questionSummary);
            });
        
            summary.style.display = 'block';
            document.getElementById('mainContainer').classList.add('summary-active');
            document.getElementById('siteWideLoading').style.display = 'none';
        }, 500);
    }
    async function playNextQuestion() {
        if (currentQuestionIndex < questions.length) {
            const question = questions[currentQuestionIndex];
            questionText.textContent = `Question ${currentQuestionIndex + 1}`;
    
            console.log('Attempting to play audio:', question.audio_data);
    
            try {
                micContainer.style.display = 'block';
                questionContainer.style.backgroundColor = '#e6f7ff';
                await playAudio(question.audio_data);
                console.log('Audio played successfully');
                startRecording();
            } catch (error) {
                console.error('Error in playNextQuestion:', error);
                alert(`Failed to play audio for question ${currentQuestionIndex + 1}. Moving to next question.`);
                moveToNextQuestion();
            }
        } else {
            completeSession();
        }
    }

    function moveToNextQuestion() {
        currentQuestionIndex++;
        if (currentQuestionIndex < questions.length) {
            setTimeout(playNextQuestion, 500);
        } else {
            completeSession();
        }
    }
    
    async function completeSession() {
        questionText.textContent = "Session completed!";
        micContainer.style.display = 'none';
        
        if (!isCompleted) {
            await updateSessionProgress();
            isCompleted = true;
        }
    }
    
    async function updateSessionProgress() {
        const formData = new FormData();
        formData.append('session_id', '{{ session.id }}');
    
        try {
            const response = await fetch("{% url 'update_interpersonal_progress' %}", {
                method: 'POST',
                body: formData,
                headers: {
                    'X-CSRFToken': '{{ csrf_token }}'
                }
            });
            const data = await response.json();
            console.log(data.message);
        } catch (error) {
            console.error('Error updating session progress:', error);
        }
    }
    
    startButton.addEventListener('click', () => {
        startButton.style.display = 'none';
        playNextQuestion();
    });
    
    mic.addEventListener('click', () => {
        if (isRecording) {
            stopRecording();
        } else {
            startRecording();
        }
    });
    
    if (isCompleted) {
        completeSession();
    } else {
        startButton.style.display = 'block';
    }
});
</script>
{% endblock %}