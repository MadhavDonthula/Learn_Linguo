{% load static %}
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>French Flashcards</title>
    <link rel="stylesheet" href="{% static 'transcription/flashcards.css' %}" />
  </head>
  <body>
    <div class="backbuttonbox">
      <a href="{% url 'home' %}" class="back-button">Back to Dashboard</a>
    </div>
    <div class="container">
      <div class="flashcard-container">
        <h1>{{flashcard_set.name}}</h1>
        <div class="flashcard" id="flashcard">
          <div class="flashcard-inner">
            <div class="word" id="french-word"></div>
            <div class="translation" id="english-translation"></div>
            <div class="icon mic" id="mic">
              <svg
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round">
                <path
                  d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
                <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                <line x1="12" y1="19" x2="12" y2="23"></line>
                <line x1="8" y1="23" x2="16" y2="23"></line>
              </svg>
              <div class="recording-indicator"></div>
            </div>
          </div>
        </div>
        <div class="checkmark" id="checkmark">✅</div>
        <div class="wrong" id="wrong">❌</div>
        <div class="transcribed-text" id="transcribed-text"></div>
        <div class="score" id="score"></div>
        <div class="missing-words" id="missing-words"></div>
        <div class="loading" id="loading">Loading...</div>
        <div class="progress-container">
          <div class="progress-bar" id="progressBar"></div>
          <div id="completionText"></div>
        </div>
        <div class="navigation">
          <div class="nav-icon" id="prevArrow">
            <svg
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round">
              <polyline points="15 18 9 12 15 6"></polyline>
            </svg>
          </div>
          <div class="nav-icon" id="nextArrow">
            <svg
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round">
              <polyline points="9 18 15 12 9 6"></polyline>
            </svg>
          </div>
        </div>
      </div>
      <div class="instructions">
        <h2>How to Use</h2>
        <ol>
          <li>Click on the flashcard to hear the French word pronounced.</li>
          <li>
            Click the microphone icon to start recording your pronunciation.
          </li>
          <li>Speak the French word clearly.</li>
          <li>Click the microphone icon again to stop recording and submit.</li>
          <li>The app will check your pronunciation and give feedback.</li>
          <li>Use the arrows to navigate between flashcards.</li>
        </ol>
      </div>
    </div>

    <form id="audioForm" method="POST" style="display: none">
      {% csrf_token %}
      <input type="hidden" name="audio_data" id="audio_data" />
      <input
        type="hidden"
        name="flashcard_id"
        id="flashcard_id"
        value="{{ flashcard.id }}" />
      <input
        type="hidden"
        name="flashcard_set_id"
        id="flashcard_set_id"
        value="{{ flashcard_set.id }}" />
    </form>

    <div class="congratulations-popup" id="congratulations-popup">
      <h1>Congratulations! You finished: {{ flashcard_set.name }}</h1>
      <button class="restart-button" id="restart-button">Restart</button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.4.0/dist/confetti.browser.min.js"></script>
    <script>
        let isRecording = false;
        let mediaRecorder;
        let audioChunks = [];
        let attemptCount = 0;
        let currentFlashcardIndex = 0;
        const maxAttempts = 2;

        let audioContext;
        let analyser;
        let microphone;
        let animationId;

        const micDiv = document.getElementById("mic");
        const checkmark = document.getElementById("checkmark");
        const wrong = document.getElementById("wrong");
        const flashcard = document.getElementById("flashcard");
        const nextArrow = document.getElementById("nextArrow");
        const prevArrow = document.getElementById("prevArrow");
        const loading = document.getElementById("loading");
        const transcribedText = document.getElementById("transcribed-text");
        const scoreElement = document.getElementById("score");
        const missingWordsElement = document.getElementById("missing-words");
        const completionIndicator = document.getElementById("completion-indicator");
        const congratulationsPopup = document.getElementById("congratulations-popup");
        const restartButton = document.getElementById("restart-button");
        const freeFlow = {{ flashcard_set.free_flow|yesno:"true,false" }}; // Get the free_flow value from the server
        const recordingTimeLimit = 4000; // 4 seconds in milliseconds
        let recordingTimeout;



        const flashcards = [
            {% for flashcard in flashcards %}
            {
                id: {{ flashcard.id }},
                french_word: "{{ flashcard.french_word|escapejs }}",
                english_translation: "{{ flashcard.english_translation|escapejs }}"
            },
            {% endfor %}
        ];

        function updateFlashcard() {
            const currentFlashcard = flashcards[currentFlashcardIndex];
            document.getElementById('french-word').textContent = currentFlashcard.french_word;
            document.getElementById('english-translation').textContent = currentFlashcard.english_translation;
            document.getElementById('flashcard_id').value = currentFlashcard.id;
            document.getElementById('flashcard_set_id').value = "{{ flashcard_set.id }}";
            resetUI();
        
            saveFlashcardIndex();
            updateCompletionPercentage();
        
            // Only show the next arrow if it's free flow mode
            if (freeFlow) {
                nextArrow.classList.add("show");
            } else {
                nextArrow.classList.remove("show");
            }
            
            // Reset attempt count for the new flashcard
            attemptCount = 0;
        }
        

        function saveFlashcardIndex() {
            fetch("{% url 'save_flashcard_index' %}", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "X-CSRFToken": document.querySelector('[name=csrfmiddlewaretoken]').value
                },
                body: JSON.stringify({
                    flashcard_set_id: "{{ flashcard_set.id }}",
                    index: currentFlashcardIndex
                })
            })
            .then(response => response.json())
            .then(data => {
                console.log('Flashcard index saved:', data);
            })
            .catch(error => console.error('Error:', error));
        }

        function loadFlashcardIndex() {
            fetch("{% url 'get_flashcard_index' %}?flashcard_set_id={{ flashcard_set.id }}")
                .then(response => response.json())
                .then(data => {
                    currentFlashcardIndex = data.index || 0;
                    updateFlashcard();
                })
                .catch(error => console.error('Error:', error));
        }
        micDiv.addEventListener("click", async (event) => {
            event.stopPropagation();
            if (!isRecording) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaRecorder = new MediaRecorder(stream);
                    audioChunks = [];
                    mediaRecorder.ondataavailable = (event) => {
                        audioChunks.push(event.data);
                    };
                    mediaRecorder.onstop = () => {
                        const audioBlob = new Blob(audioChunks, { type: "audio/wav" });
                        const reader = new FileReader();
                        reader.readAsDataURL(audioBlob);
                        reader.onloadend = () => {
                            const base64String = reader.result.split(',')[1];
                            document.getElementById("audio_data").value = base64String;
                            checkPronunciation(base64String);
                        };
                    };
                    mediaRecorder.start();
                    isRecording = true;
                    micDiv.classList.add("recording");
        
                    // Set up audio analysis
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    analyser = audioContext.createAnalyser();
                    microphone = audioContext.createMediaStreamSource(stream);
                    microphone.connect(analyser);
                    analyser.fftSize = 256;
                    animateRecordingIndicator();
        
                    // Set up recording time limit
                    recordingTimeout = setTimeout(() => {
                        if (isRecording) {
                            stopRecording();
                        }
                    }, recordingTimeLimit);
        
                } catch (error) {
                    console.error("Error accessing audio", error);
                }
            } else {
                stopRecording();
            }
        });
        
        function stopRecording() {
            clearTimeout(recordingTimeout);
            if (mediaRecorder) {
                mediaRecorder.stop();
                isRecording = false;
                micDiv.classList.remove("recording");
                loading.style.display = "block";
        
                // Stop audio analysis
                if (audioContext) {
                    audioContext.close();
                }
                if (animationId) {
                    cancelAnimationFrame(animationId);
                }
            }
        }

        function animateRecordingIndicator() {
            if (!isRecording) return;

            const dataArray = new Uint8Array(analyser.frequencyBinCount);
            analyser.getByteFrequencyData(dataArray);

            const average = dataArray.reduce((acc, val) => acc + val, 0) / dataArray.length;
            const scale = 1 + (average / 256) * 0.5; // Max scale of 1.5

            const recordingIndicator = micDiv.querySelector('.recording-indicator');
            recordingIndicator.style.transform = `scale(${scale})`;

            animationId = requestAnimationFrame(animateRecordingIndicator);
        }

        flashcard.addEventListener("click", () => {
            if (!isRecording) {
                const currentFlashcard = flashcards[currentFlashcardIndex];
                const utterance = new SpeechSynthesisUtterance(currentFlashcard.french_word);
                utterance.lang = 'fr-FR';
                speechSynthesis.speak(utterance);
            }
        });

        function checkPronunciation(audioData) {
            const form = document.getElementById("audioForm");
            const formData = new FormData(form);

            fetch("{% url 'check_pronunciation' %}", {
                method: "POST",
                body: formData,
                headers: {
                    "X-CSRFToken": formData.get("csrfmiddlewaretoken"),
                },
            })
            .then((response) => response.json())
            .then((data) => {
                loading.style.display = "none";
                if (data.correct) {
                    showCheckmark();
                } else {
                    showWrong(data.transcribed_text, data.score, data.missing_words);
                }
            })
            .catch((error) => {
                console.error("Error:", error);
                loading.style.display = "none";
            });
        }

        function showCheckmark() {
            checkmark.classList.add("show");
            wrong.classList.remove("show");
            transcribedText.textContent = "";
            transcribedText.style.display = "none";
            scoreElement.textContent = "";
            missingWordsElement.textContent = "";
            resetMic();
    
            // Wait for a short moment to show the checkmark, then move to the next card
            setTimeout(() => {
                if (currentFlashcardIndex < flashcards.length - 1) {
                    currentFlashcardIndex++;
                    updateFlashcard();
                } else {
                    showCongratulationsPopup();
                }
            }, 1000); // Wait for 1 second before moving to the next card
        }

        function showWrong(transcribed, score) {
            wrong.classList.add("show");
            transcribedText.textContent = `You said: ${transcribed}`;
            transcribedText.style.display = "block";
            scoreElement.textContent = `Score: ${score}`;
            
            attemptCount++;
            
            if (attemptCount >= maxAttempts || freeFlow) {
                nextArrow.classList.add("show");
            }
            
            if (attemptCount >= maxAttempts) {
                resetMic();
            }
        }
    

        function resetMic() {
            micDiv.classList.remove("recording");
            isRecording = false;
            audioChunks = [];
            attemptCount = 0;
            if (audioContext) {
                audioContext.close();
            }
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            const recordingIndicator = micDiv.querySelector('.recording-indicator');
            recordingIndicator.style.transform = 'scale(1)';
        }

        function resetUI() {
            checkmark.classList.remove("show");
            wrong.classList.remove("show");
            if (!freeFlow) {
                nextArrow.classList.remove("show");
            }
            transcribedText.style.display = "none";
            scoreElement.textContent = "";
            missingWordsElement.textContent = "";
            micDiv.style.display = "block";
        }

        function updateCompletionPercentage() {
            const percentage = Math.round(((currentFlashcardIndex + 1) / flashcards.length) * 100);
            const progressBar = document.getElementById('progressBar');
            const completionText = document.getElementById('completionText');

            progressBar.style.width = `${percentage}%`;
            completionText.textContent = `${percentage}% Completed`;

            fetch("{% url 'update_progress' %}", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "X-CSRFToken": document.querySelector('[name=csrfmiddlewaretoken]').value
                },
                body: JSON.stringify({
                    user_id: "{{ user.id }}",
                    flashcard_set_id: "{{ flashcard_set.id }}",
                    percentage: percentage
                })
            })
            .then(response => response.json())
            .catch(error => console.error('Error:', error));
        }

        nextArrow.addEventListener("click", () => {
            if (freeFlow || attemptCount >= maxAttempts || checkmark.classList.contains("show")) {
                if (currentFlashcardIndex < flashcards.length - 1) {
                    currentFlashcardIndex++;
                    updateFlashcard();
                    resetMic();
                } else {
                    showCongratulationsPopup();
                }
            }
        });
        prevArrow.addEventListener("click", () => {
            if (currentFlashcardIndex > 0) {
                currentFlashcardIndex--;
                updateFlashcard();
            }
        });

        function showCongratulationsPopup() {
            congratulationsPopup.style.display = "block";
            confetti();
        }

        restartButton.addEventListener("click", () => {
            congratulationsPopup.style.display = "none";
            currentFlashcardIndex = 0;
            updateFlashcard();
        });

        document.addEventListener("DOMContentLoaded", () => {
            loadFlashcardIndex();
        });
    </script>
  </body>
</html>
